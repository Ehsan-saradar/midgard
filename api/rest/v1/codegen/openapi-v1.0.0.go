// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
	"time"
)

// Asset defines model for Asset.
type Asset struct {
	Chain  *string `json:"chain,omitempty"`
	Symbol *string `json:"symbol,omitempty"`
	Ticker *string `json:"ticker,omitempty"`
}

// AssetDetail defines model for AssetDetail.
type AssetDetail struct {
	Asset       *string    `json:"Asset,omitempty"`
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	Logo        *string    `json:"Logo,omitempty"`
	Name        *string    `json:"Name,omitempty"`
	Ticker      *string    `json:"Ticker,omitempty"`
	PriceRune   *float64   `json:"priceRune,omitempty"`
	PriceUSD    *float64   `json:"priceUSD,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Error string `json:"error"`
}

// PoolData defines model for PoolData.
type PoolData struct {
	Asset         string  `json:"asset"`
	Depth         float32 `json:"depth"`
	NumStakeTx    float32 `json:"numStakeTx"`
	NumStakers    float32 `json:"numStakers"`
	NumSwaps      float32 `json:"numSwaps"`
	PoolUnits     float32 `json:"poolUnits"`
	Roi12         float32 `json:"roi12"`
	Roi30         float32 `json:"roi30"`
	RoiAT         float32 `json:"roiAT"`
	TotalFeesRune float32 `json:"totalFeesRune"`
	TotalFeesTKN  float32 `json:"totalFeesTKN"`
	Vol24hr       float32 `json:"vol24hr"`
	VolAT         float32 `json:"volAT"`
}

// StakerInfo defines model for StakerInfo.
type StakerInfo struct {
	Address         string  `json:"address"`
	Asset           string  `json:"asset"`
	DateFirstStaked string  `json:"dateFirstStaked"`
	RuneEarned      float32 `json:"runeEarned"`
	RuneStaked      float32 `json:"runeStaked"`
	TokensEarned    float32 `json:"tokensEarned"`
	TokensStaked    float32 `json:"tokensStaked"`
	Units           float32 `json:"units"`
}

// StakerInfoWithAsset defines model for StakerInfoWithAsset.
type StakerInfoWithAsset []string

// SwapData defines model for SwapData.
type SwapData struct {
	Asset       string  `json:"asset"`
	AveFeeRune  float32 `json:"aveFeeRune"`
	AveFeeTkn   float32 `json:"aveFeeTkn"`
	AveSlipRune float32 `json:"aveSlipRune"`
	AveSlipTkn  float32 `json:"aveSlipTkn"`
	AveTxRune   float32 `json:"aveTxRune"`
	AveTxTkn    float32 `json:"aveTxTkn"`
	NumTxRune   float32 `json:"numTxRune"`
	NumTxTkn    float32 `json:"numTxTkn"`
}

// AssetsDetailedResponse defines model for AssetsDetailedResponse.
type AssetsDetailedResponse AssetDetail

// AssetsResponse defines model for AssetsResponse.
type AssetsResponse []Asset

// GeneralErrorResponse defines model for GeneralErrorResponse.
type GeneralErrorResponse Error

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	Asset *string `json:"asset,omitempty"`
}

// GetPoolDataParams defines parameters for GetPoolData.
type GetPoolDataParams struct {
	Asset string `json:"asset"`
}

// GetStakerDataParams defines parameters for GetStakerData.
type GetStakerDataParams struct {
	Staker string  `json:"staker"`
	Asset  *string `json:"asset,omitempty"`
}

// GetStakerTxParams defines parameters for GetStakerTx.
type GetStakerTxParams struct {
	Staker string  `json:"staker"`
	Limit  *int    `json:"limit,omitempty"`
	Offset *int    `json:"offset,omitempty"`
	Asset  *string `json:"asset,omitempty"`
}

// GetSwapDataParams defines parameters for GetSwapData.
type GetSwapDataParams struct {
	Asset string `json:"asset"`
}

// GetSwapTxParams defines parameters for GetSwapTx.
type GetSwapTxParams struct {
	Asset  string `json:"asset"`
	Sender string `json:"sender"`
	Dest   string `json:"dest"`
	Limit  *int   `json:"limit,omitempty"`
	Offset *int   `json:"offset,omitempty"`
}

// GetTokenDataParams defines parameters for GetTokenData.
type GetTokenDataParams struct {
	Symbol string `json:"symbol"`
}

// GetTradeDataParams defines parameters for GetTradeData.
type GetTradeDataParams struct {
	Symbol string `json:"symbol"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// (GET /v1/assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// (GET /v1/assets/{asset})
	GetAssetInfo(ctx echo.Context, asset string) error
	// This swagger/openapi 3.0 generated documentation// (GET /v1/doc)
	GetDocs(ctx echo.Context) error
	// (GET /v1/graphql)
	GetGraphqlPlayground(ctx echo.Context) error
	// (POST /v1/graphql/query)
	PostGraphqlQuery(ctx echo.Context) error
	// (GET /v1/health)
	GetHealth(ctx echo.Context) error
	// (GET /v1/poolData)
	GetPoolData(ctx echo.Context, params GetPoolDataParams) error
	// (GET /v1/stakerData)
	GetStakerData(ctx echo.Context, params GetStakerDataParams) error
	// (GET /v1/stakerTx)
	GetStakerTx(ctx echo.Context, params GetStakerTxParams) error
	// JSON swagger/openapi 3.0 specification endpoint// (GET /v1/swagger.json)
	GetSwagger(ctx echo.Context) error
	// (GET /v1/swapData)
	GetSwapData(ctx echo.Context, params GetSwapDataParams) error
	// (GET /v1/swapTx)
	GetSwapTx(ctx echo.Context, params GetSwapTxParams) error
	// (GET /v1/tokenData)
	GetTokenData(ctx echo.Context, params GetTokenDataParams) error
	// (GET /v1/tradeData)
	GetTradeData(ctx echo.Context, params GetTradeDataParams) error
	// (GET /v1/userData)
	GetUserData(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// GetAssetInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset" -------------
	var asset string

	err = runtime.BindStyledParameter("simple", false, "asset", ctx.Param("asset"), &asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetInfo(ctx, asset)
	return err
}

// GetDocs converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocs(ctx)
	return err
}

// GetGraphqlPlayground converts echo context to params.
func (w *ServerInterfaceWrapper) GetGraphqlPlayground(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGraphqlPlayground(ctx)
	return err
}

// PostGraphqlQuery converts echo context to params.
func (w *ServerInterfaceWrapper) PostGraphqlQuery(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGraphqlQuery(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetPoolData converts echo context to params.
func (w *ServerInterfaceWrapper) GetPoolData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoolDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPoolData(ctx, params)
	return err
}

// GetStakerData converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerDataParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerData(ctx, params)
	return err
}

// GetStakerTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerTxParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerTx(ctx, params)
	return err
}

// GetSwagger converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwagger(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwagger(ctx)
	return err
}

// GetSwapData converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapData(ctx, params)
	return err
}

// GetSwapTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapTxParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Required query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument sender is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Required query parameter "dest" -------------
	if paramValue := ctx.QueryParam("dest"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument dest is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "dest", ctx.QueryParams(), &params.Dest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dest: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapTx(ctx, params)
	return err
}

// GetTokenData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTokenData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokenDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTokenData(ctx, params)
	return err
}

// GetTradeData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTradeData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTradeDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTradeData(ctx, params)
	return err
}

// GetUserData converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserData(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserData(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v1/assets", wrapper.GetAssets)
	router.GET("/v1/assets/:asset", wrapper.GetAssetInfo)
	router.GET("/v1/doc", wrapper.GetDocs)
	router.GET("/v1/graphql", wrapper.GetGraphqlPlayground)
	router.POST("/v1/graphql/query", wrapper.PostGraphqlQuery)
	router.GET("/v1/health", wrapper.GetHealth)
	router.GET("/v1/poolData", wrapper.GetPoolData)
	router.GET("/v1/stakerData", wrapper.GetStakerData)
	router.GET("/v1/stakerTx", wrapper.GetStakerTx)
	router.GET("/v1/swagger.json", wrapper.GetSwagger)
	router.GET("/v1/swapData", wrapper.GetSwapData)
	router.GET("/v1/swapTx", wrapper.GetSwapTx)
	router.GET("/v1/tokenData", wrapper.GetTokenData)
	router.GET("/v1/tradeData", wrapper.GetTradeData)
	router.GET("/v1/userData", wrapper.GetUserData)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/wAAAP//d5ySel8dAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
