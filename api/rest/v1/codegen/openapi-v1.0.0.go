// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// Asset defines model for Asset.
type Asset struct {
	Chain  *string `json:"chain,omitempty"`
	Symbol *string `json:"symbol,omitempty"`
	Ticker *string `json:"ticker,omitempty"`
}

// PoolData defines model for PoolData.
type PoolData struct {
	Asset         string  `json:"asset"`
	Depth         float32 `json:"depth"`
	NumStakeTx    float32 `json:"numStakeTx"`
	NumStakers    float32 `json:"numStakers"`
	NumSwaps      float32 `json:"numSwaps"`
	PoolUnits     float32 `json:"poolUnits"`
	Roi12         float32 `json:"roi12"`
	Roi30         float32 `json:"roi30"`
	RoiAT         float32 `json:"roiAT"`
	TotalFeesRune float32 `json:"totalFeesRune"`
	TotalFeesTKN  float32 `json:"totalFeesTKN"`
	Vol24hr       float32 `json:"vol24hr"`
	VolAT         float32 `json:"volAT"`
}

// StakerInfo defines model for StakerInfo.
type StakerInfo struct {
	Address         string  `json:"address"`
	Asset           string  `json:"asset"`
	DateFirstStaked string  `json:"dateFirstStaked"`
	RuneEarned      float32 `json:"runeEarned"`
	RuneStaked      float32 `json:"runeStaked"`
	TokensEarned    float32 `json:"tokensEarned"`
	TokensStaked    float32 `json:"tokensStaked"`
	Units           float32 `json:"units"`
}

// StakerInfoWithAsset defines model for StakerInfoWithAsset.
type StakerInfoWithAsset []string

// SwapData defines model for SwapData.
type SwapData struct {
	Asset       string  `json:"asset"`
	AveFeeRune  float32 `json:"aveFeeRune"`
	AveFeeTkn   float32 `json:"aveFeeTkn"`
	AveSlipRune float32 `json:"aveSlipRune"`
	AveSlipTkn  float32 `json:"aveSlipTkn"`
	AveTxRune   float32 `json:"aveTxRune"`
	AveTxTkn    float32 `json:"aveTxTkn"`
	NumTxRune   float32 `json:"numTxRune"`
	NumTxTkn    float32 `json:"numTxTkn"`
}

// TokenData defines model for TokenData.
type TokenData struct {
	Price  float32 `json:"price"`
	Symbol string  `json:"symbol"`
	Ticker string  `json:"ticker"`
}

// TokenList defines model for TokenList.
type TokenList []string

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	Asset *string `json:"asset,omitempty"`
}

// GetPoolDataParams defines parameters for GetPoolData.
type GetPoolDataParams struct {
	Asset string `json:"asset"`
}

// GetStakerDataParams defines parameters for GetStakerData.
type GetStakerDataParams struct {
	Staker string  `json:"staker"`
	Asset  *string `json:"asset,omitempty"`
}

// GetStakerTxParams defines parameters for GetStakerTx.
type GetStakerTxParams struct {
	Staker string  `json:"staker"`
	Limit  *int    `json:"limit,omitempty"`
	Offset *int    `json:"offset,omitempty"`
	Asset  *string `json:"asset,omitempty"`
}

// GetSwapDataParams defines parameters for GetSwapData.
type GetSwapDataParams struct {
	Asset string `json:"asset"`
}

// GetSwapTxParams defines parameters for GetSwapTx.
type GetSwapTxParams struct {
	Asset  string `json:"asset"`
	Sender string `json:"sender"`
	Dest   string `json:"dest"`
	Limit  *int   `json:"limit,omitempty"`
	Offset *int   `json:"offset,omitempty"`
}

// GetTokenDataParams defines parameters for GetTokenData.
type GetTokenDataParams struct {
	Symbol string `json:"symbol"`
}

// GetTradeDataParams defines parameters for GetTradeData.
type GetTradeDataParams struct {
	Symbol string `json:"symbol"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// (GET /v1/assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// This swagger/openapi 3.0 generated documentation// (GET /v1/doc)
	GetDocs(ctx echo.Context) error
	// (GET /v1/graphql)
	GetGraphqlPlayground(ctx echo.Context) error
	// (POST /v1/graphql/query)
	PostGraphqlQuery(ctx echo.Context) error
	// (GET /v1/health)
	GetHealth(ctx echo.Context) error
	// (GET /v1/poolData)
	GetPoolData(ctx echo.Context, params GetPoolDataParams) error
	// (GET /v1/stakerData)
	GetStakerData(ctx echo.Context, params GetStakerDataParams) error
	// (GET /v1/stakerTx)
	GetStakerTx(ctx echo.Context, params GetStakerTxParams) error
	// JSON swagger/openapi 3.0 specification endpoint// (GET /v1/swagger.json)
	GetSwagger(ctx echo.Context) error
	// (GET /v1/swapData)
	GetSwapData(ctx echo.Context, params GetSwapDataParams) error
	// (GET /v1/swapTx)
	GetSwapTx(ctx echo.Context, params GetSwapTxParams) error
	// (GET /v1/tokenData)
	GetTokenData(ctx echo.Context, params GetTokenDataParams) error
	// (GET /v1/tradeData)
	GetTradeData(ctx echo.Context, params GetTradeDataParams) error
	// (GET /v1/userData)
	GetUserData(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// GetDocs converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocs(ctx)
	return err
}

// GetGraphqlPlayground converts echo context to params.
func (w *ServerInterfaceWrapper) GetGraphqlPlayground(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGraphqlPlayground(ctx)
	return err
}

// PostGraphqlQuery converts echo context to params.
func (w *ServerInterfaceWrapper) PostGraphqlQuery(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGraphqlQuery(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetPoolData converts echo context to params.
func (w *ServerInterfaceWrapper) GetPoolData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoolDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPoolData(ctx, params)
	return err
}

// GetStakerData converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerDataParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerData(ctx, params)
	return err
}

// GetStakerTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerTxParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerTx(ctx, params)
	return err
}

// GetSwagger converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwagger(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwagger(ctx)
	return err
}

// GetSwapData converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapData(ctx, params)
	return err
}

// GetSwapTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapTxParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Required query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument sender is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Required query parameter "dest" -------------
	if paramValue := ctx.QueryParam("dest"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument dest is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "dest", ctx.QueryParams(), &params.Dest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dest: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapTx(ctx, params)
	return err
}

// GetTokenData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTokenData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokenDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTokenData(ctx, params)
	return err
}

// GetTradeData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTradeData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTradeDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTradeData(ctx, params)
	return err
}

// GetUserData converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserData(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserData(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v1/assets", wrapper.GetAssets)
	router.GET("/v1/doc", wrapper.GetDocs)
	router.GET("/v1/graphql", wrapper.GetGraphqlPlayground)
	router.POST("/v1/graphql/query", wrapper.PostGraphqlQuery)
	router.GET("/v1/health", wrapper.GetHealth)
	router.GET("/v1/poolData", wrapper.GetPoolData)
	router.GET("/v1/stakerData", wrapper.GetStakerData)
	router.GET("/v1/stakerTx", wrapper.GetStakerTx)
	router.GET("/v1/swagger.json", wrapper.GetSwagger)
	router.GET("/v1/swapData", wrapper.GetSwapData)
	router.GET("/v1/swapTx", wrapper.GetSwapTx)
	router.GET("/v1/tokenData", wrapper.GetTokenData)
	router.GET("/v1/tradeData", wrapper.GetTradeData)
	router.GET("/v1/userData", wrapper.GetUserData)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RYX2/bNhD/KgQ3YC+p7CQbVvhp2dJk2YomjV3sofADI50tNhLJkJQTo8h3H0jqv0lZ",
	"adoUfbN1d/zx7n73R/qMY54LzoBphWefsYpTyIn9eaIUaPNDSC5Aagr2cZwSyswPvRWAZ1hpSdkaPx5g",
	"tc1veOYVaRrfgvSIjMw94TefINZG+Yrz7JRosotNqivtACQgdNqSsCK/AWkkrMjnmtzC4mFQLFVQfE+E",
	"Xyg4zz4wqv1SyenhUUhyPA1JThZeieaaZGcA6rpgMKyx+PedV2HDs6NfUxmSeYHNneCuoBISPPtYJqCH",
	"1b9cg1SdW+WnHbLK2SocVcA6Kemkr5WNpYc2zuaCrbiHOEkiQSkvdQZIRTScUam0PTrx6siCwRsiWUfc",
	"SmjBYMe6nbNbYGrA3ikMnFAE+NdPXBmAgzqFfec6rnQu3rtm71LVFYZT8h/Vad1QqIbcn4vyAZGSbO0B",
	"90Q8tRWQDZwBBMvEiRe3LCSdZ1QMWRv5gPniYch48RAyZUU+YGqlftNAidZg7Vt1HOh628JoX6YdsE5s",
	"ffleGGL48yUkjf2ufeHYaPtcHlEbHJRwwTu+pepJTDSAtOwsMWeaxNYcckIzPMMJbNQfOuXSDseIy3Im",
	"qVhSoSlneIb/MqJXc5AbGgO6Km4yGqOTqwt7a53BsMoGpHLnHEbTaPqKE3VsMLgARgTFM3xsnhvPiU6t",
	"S5PN4cSSwf5bu2rp3ukadCGZQoQh6yiyvlFG2RqRLEM6BeSOQKoQgksNSYQtqiTmjIsEz/A56BOHY9Al",
	"yUHbcfqxDzcXENPVFlUUNXsEvitAbg3lSG4DXsqa9K5IpuCg3Ex8XFgabSU4U45qR9NplSdg1msiREZj",
	"e+PJJ8VZs+l0SPCzhBWe4Z8mzU40KReiiWteXmJ0nTwHjSzHFFpJntv8PVo9k5CEx61s7MTxlMd2Mnrc",
	"6aKoe7Jeg5yU+UfH0RQpATFaAzNnQoISc5bBVUWeE7nFM7xIqUI+045VkQPT9lqGm2RtUolPO8+XlT9r",
	"SUR6lw35dO5UrjKyXUtesGSUg9bq/VskGrMmiiXqxHHHdBeuPOBXXFXo70uWPRM4BZK5PTPk7d9OYxQS",
	"aOTUkVOOAfFVjzCitQyHMOuFeU/9GcBODSJjiUrTcdWoZfFNi3GoBms/PWVn6xOZaCHTqGXuiNoEUtld",
	"ZF8o543WnmC681CzWPni55SeFMCDH6RrcgaXKxuXoZS1lnLj2TjVZll8XAY6rFO2qbb89fVaF3z33jec",
	"b/tyMTy6XirbGc2pNv2gyLRC0g5o05ZhRYpMo6PfAtjWbhQDKNOwdotjH5yvVqaKoiiqATVH0wCk034u",
	"5svSO8gkLQlTJDaCMKHc5IyqYgiSyumNGgJpkZvtiyUoJ3FKGSAJJCE3GewMamUjVVYkApYITpnujfh/",
	"5pfvUGg78Fg3E37eVmgmvGq9gg04LMb0zC/L9fccObVnnj5kZCgxXAlMnHsi9nQfp7Enal83WjsFqIAl",
	"+1ubVXoeUAJK74ExKt+if0bo9EUa6KVtiQ3a1+6e47ua4eaYnqbbr+whnjbv9SMLvH4h93KpEj67xANv",
	"XmFnJUlgr7O10r4N8Ls5aW4YdLJQ+9fcD6pecsdBGgMPohk9IDdVfAqZmZGmtZhNJodHv0fTaBodzl5P",
	"X0/t+tfIlUdhWc+i/g3KTyF/gjA9FXW+k/yi0PWb+aL8TlJGP/gl5XH5+H8AAAD//0+vgV/zGAAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
