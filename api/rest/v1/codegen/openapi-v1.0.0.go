// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// Asset defines model for Asset.
type Asset struct {
	Chain  *string `json:"chain,omitempty"`
	Symbol *string `json:"symbol,omitempty"`
	Ticker *string `json:"ticker,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Error string `json:"error"`
}

// PoolData defines model for PoolData.
type PoolData struct {
	Asset         string  `json:"asset"`
	Depth         float32 `json:"depth"`
	NumStakeTx    float32 `json:"numStakeTx"`
	NumStakers    float32 `json:"numStakers"`
	NumSwaps      float32 `json:"numSwaps"`
	PoolUnits     float32 `json:"poolUnits"`
	Roi12         float32 `json:"roi12"`
	Roi30         float32 `json:"roi30"`
	RoiAT         float32 `json:"roiAT"`
	TotalFeesRune float32 `json:"totalFeesRune"`
	TotalFeesTKN  float32 `json:"totalFeesTKN"`
	Vol24hr       float32 `json:"vol24hr"`
	VolAT         float32 `json:"volAT"`
}

// StakerInfo defines model for StakerInfo.
type StakerInfo struct {
	Address         string  `json:"address"`
	Asset           string  `json:"asset"`
	DateFirstStaked string  `json:"dateFirstStaked"`
	RuneEarned      float32 `json:"runeEarned"`
	RuneStaked      float32 `json:"runeStaked"`
	TokensEarned    float32 `json:"tokensEarned"`
	TokensStaked    float32 `json:"tokensStaked"`
	Units           float32 `json:"units"`
}

// StakerInfoWithAsset defines model for StakerInfoWithAsset.
type StakerInfoWithAsset []string

// SwapData defines model for SwapData.
type SwapData struct {
	Asset       string  `json:"asset"`
	AveFeeRune  float32 `json:"aveFeeRune"`
	AveFeeTkn   float32 `json:"aveFeeTkn"`
	AveSlipRune float32 `json:"aveSlipRune"`
	AveSlipTkn  float32 `json:"aveSlipTkn"`
	AveTxRune   float32 `json:"aveTxRune"`
	AveTxTkn    float32 `json:"aveTxTkn"`
	NumTxRune   float32 `json:"numTxRune"`
	NumTxTkn    float32 `json:"numTxTkn"`
}

// AssetsResponse defines model for AssetsResponse.
type AssetsResponse []Asset

// GeneralErrorResponse defines model for GeneralErrorResponse.
type GeneralErrorResponse Error

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	Asset *string `json:"asset,omitempty"`
}

// GetPoolDataParams defines parameters for GetPoolData.
type GetPoolDataParams struct {
	Asset string `json:"asset"`
}

// GetStakerDataParams defines parameters for GetStakerData.
type GetStakerDataParams struct {
	Staker string  `json:"staker"`
	Asset  *string `json:"asset,omitempty"`
}

// GetStakerTxParams defines parameters for GetStakerTx.
type GetStakerTxParams struct {
	Staker string  `json:"staker"`
	Limit  *int    `json:"limit,omitempty"`
	Offset *int    `json:"offset,omitempty"`
	Asset  *string `json:"asset,omitempty"`
}

// GetSwapDataParams defines parameters for GetSwapData.
type GetSwapDataParams struct {
	Asset string `json:"asset"`
}

// GetSwapTxParams defines parameters for GetSwapTx.
type GetSwapTxParams struct {
	Asset  string `json:"asset"`
	Sender string `json:"sender"`
	Dest   string `json:"dest"`
	Limit  *int   `json:"limit,omitempty"`
	Offset *int   `json:"offset,omitempty"`
}

// GetTokenDataParams defines parameters for GetTokenData.
type GetTokenDataParams struct {
	Symbol string `json:"symbol"`
}

// GetTradeDataParams defines parameters for GetTradeData.
type GetTradeDataParams struct {
	Symbol string `json:"symbol"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// (GET /v1/assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// (GET /v1/assets/{asset})
	GetAssetInfo(ctx echo.Context, asset string) error
	// This swagger/openapi 3.0 generated documentation// (GET /v1/doc)
	GetDocs(ctx echo.Context) error
	// (GET /v1/graphql)
	GetGraphqlPlayground(ctx echo.Context) error
	// (POST /v1/graphql/query)
	PostGraphqlQuery(ctx echo.Context) error
	// (GET /v1/health)
	GetHealth(ctx echo.Context) error
	// (GET /v1/poolData)
	GetPoolData(ctx echo.Context, params GetPoolDataParams) error
	// (GET /v1/stakerData)
	GetStakerData(ctx echo.Context, params GetStakerDataParams) error
	// (GET /v1/stakerTx)
	GetStakerTx(ctx echo.Context, params GetStakerTxParams) error
	// JSON swagger/openapi 3.0 specification endpoint// (GET /v1/swagger.json)
	GetSwagger(ctx echo.Context) error
	// (GET /v1/swapData)
	GetSwapData(ctx echo.Context, params GetSwapDataParams) error
	// (GET /v1/swapTx)
	GetSwapTx(ctx echo.Context, params GetSwapTxParams) error
	// (GET /v1/tokenData)
	GetTokenData(ctx echo.Context, params GetTokenDataParams) error
	// (GET /v1/tradeData)
	GetTradeData(ctx echo.Context, params GetTradeDataParams) error
	// (GET /v1/userData)
	GetUserData(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// GetAssetInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset" -------------
	var asset string

	err = runtime.BindStyledParameter("simple", false, "asset", ctx.Param("asset"), &asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetInfo(ctx, asset)
	return err
}

// GetDocs converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocs(ctx)
	return err
}

// GetGraphqlPlayground converts echo context to params.
func (w *ServerInterfaceWrapper) GetGraphqlPlayground(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGraphqlPlayground(ctx)
	return err
}

// PostGraphqlQuery converts echo context to params.
func (w *ServerInterfaceWrapper) PostGraphqlQuery(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGraphqlQuery(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetPoolData converts echo context to params.
func (w *ServerInterfaceWrapper) GetPoolData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoolDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPoolData(ctx, params)
	return err
}

// GetStakerData converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerDataParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerData(ctx, params)
	return err
}

// GetStakerTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerTxParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerTx(ctx, params)
	return err
}

// GetSwagger converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwagger(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwagger(ctx)
	return err
}

// GetSwapData converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapData(ctx, params)
	return err
}

// GetSwapTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapTxParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Required query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument sender is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Required query parameter "dest" -------------
	if paramValue := ctx.QueryParam("dest"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument dest is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "dest", ctx.QueryParams(), &params.Dest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dest: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapTx(ctx, params)
	return err
}

// GetTokenData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTokenData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokenDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTokenData(ctx, params)
	return err
}

// GetTradeData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTradeData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTradeDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTradeData(ctx, params)
	return err
}

// GetUserData converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserData(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserData(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v1/assets", wrapper.GetAssets)
	router.GET("/v1/assets/:asset", wrapper.GetAssetInfo)
	router.GET("/v1/doc", wrapper.GetDocs)
	router.GET("/v1/graphql", wrapper.GetGraphqlPlayground)
	router.POST("/v1/graphql/query", wrapper.PostGraphqlQuery)
	router.GET("/v1/health", wrapper.GetHealth)
	router.GET("/v1/poolData", wrapper.GetPoolData)
	router.GET("/v1/stakerData", wrapper.GetStakerData)
	router.GET("/v1/stakerTx", wrapper.GetStakerTx)
	router.GET("/v1/swagger.json", wrapper.GetSwagger)
	router.GET("/v1/swapData", wrapper.GetSwapData)
	router.GET("/v1/swapTx", wrapper.GetSwapTx)
	router.GET("/v1/tokenData", wrapper.GetTokenData)
	router.GET("/v1/tradeData", wrapper.GetTradeData)
	router.GET("/v1/userData", wrapper.GetUserData)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
