// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// Asset defines model for Asset.
type Asset struct {
	Chain  *string `json:"chain,omitempty"`
	Symbol *string `json:"symbol,omitempty"`
	Ticker *string `json:"ticker,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Error string `json:"error"`
}

// PoolData defines model for PoolData.
type PoolData struct {
	Asset         string  `json:"asset"`
	Depth         float32 `json:"depth"`
	NumStakeTx    float32 `json:"numStakeTx"`
	NumStakers    float32 `json:"numStakers"`
	NumSwaps      float32 `json:"numSwaps"`
	PoolUnits     float32 `json:"poolUnits"`
	Roi12         float32 `json:"roi12"`
	Roi30         float32 `json:"roi30"`
	RoiAT         float32 `json:"roiAT"`
	TotalFeesRune float32 `json:"totalFeesRune"`
	TotalFeesTKN  float32 `json:"totalFeesTKN"`
	Vol24hr       float32 `json:"vol24hr"`
	VolAT         float32 `json:"volAT"`
}

// StakerInfo defines model for StakerInfo.
type StakerInfo struct {
	Address         string  `json:"address"`
	Asset           string  `json:"asset"`
	DateFirstStaked string  `json:"dateFirstStaked"`
	RuneEarned      float32 `json:"runeEarned"`
	RuneStaked      float32 `json:"runeStaked"`
	TokensEarned    float32 `json:"tokensEarned"`
	TokensStaked    float32 `json:"tokensStaked"`
	Units           float32 `json:"units"`
}

// StakerInfoWithAsset defines model for StakerInfoWithAsset.
type StakerInfoWithAsset []string

// SwapData defines model for SwapData.
type SwapData struct {
	Asset       string  `json:"asset"`
	AveFeeRune  float32 `json:"aveFeeRune"`
	AveFeeTkn   float32 `json:"aveFeeTkn"`
	AveSlipRune float32 `json:"aveSlipRune"`
	AveSlipTkn  float32 `json:"aveSlipTkn"`
	AveTxRune   float32 `json:"aveTxRune"`
	AveTxTkn    float32 `json:"aveTxTkn"`
	NumTxRune   float32 `json:"numTxRune"`
	NumTxTkn    float32 `json:"numTxTkn"`
}

// AssetsResponse defines model for AssetsResponse.
type AssetsResponse []Asset

// GeneralErrorResponse defines model for GeneralErrorResponse.
type GeneralErrorResponse Error

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	Asset *string `json:"asset,omitempty"`
}

// GetPoolDataParams defines parameters for GetPoolData.
type GetPoolDataParams struct {
	Asset string `json:"asset"`
}

// GetStakerDataParams defines parameters for GetStakerData.
type GetStakerDataParams struct {
	Staker string  `json:"staker"`
	Asset  *string `json:"asset,omitempty"`
}

// GetStakerTxParams defines parameters for GetStakerTx.
type GetStakerTxParams struct {
	Staker string  `json:"staker"`
	Limit  *int    `json:"limit,omitempty"`
	Offset *int    `json:"offset,omitempty"`
	Asset  *string `json:"asset,omitempty"`
}

// GetSwapDataParams defines parameters for GetSwapData.
type GetSwapDataParams struct {
	Asset string `json:"asset"`
}

// GetSwapTxParams defines parameters for GetSwapTx.
type GetSwapTxParams struct {
	Asset  string `json:"asset"`
	Sender string `json:"sender"`
	Dest   string `json:"dest"`
	Limit  *int   `json:"limit,omitempty"`
	Offset *int   `json:"offset,omitempty"`
}

// GetTokenDataParams defines parameters for GetTokenData.
type GetTokenDataParams struct {
	Symbol string `json:"symbol"`
}

// GetTradeDataParams defines parameters for GetTradeData.
type GetTradeDataParams struct {
	Symbol string `json:"symbol"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// (GET /v1/assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// This swagger/openapi 3.0 generated documentation// (GET /v1/doc)
	GetDocs(ctx echo.Context) error
	// (GET /v1/graphql)
	GetGraphqlPlayground(ctx echo.Context) error
	// (POST /v1/graphql/query)
	PostGraphqlQuery(ctx echo.Context) error
	// (GET /v1/health)
	GetHealth(ctx echo.Context) error
	// (GET /v1/poolData)
	GetPoolData(ctx echo.Context, params GetPoolDataParams) error
	// (GET /v1/stakerData)
	GetStakerData(ctx echo.Context, params GetStakerDataParams) error
	// (GET /v1/stakerTx)
	GetStakerTx(ctx echo.Context, params GetStakerTxParams) error
	// JSON swagger/openapi 3.0 specification endpoint// (GET /v1/swagger.json)
	GetSwagger(ctx echo.Context) error
	// (GET /v1/swapData)
	GetSwapData(ctx echo.Context, params GetSwapDataParams) error
	// (GET /v1/swapTx)
	GetSwapTx(ctx echo.Context, params GetSwapTxParams) error
	// (GET /v1/tokenData)
	GetTokenData(ctx echo.Context, params GetTokenDataParams) error
	// (GET /v1/tradeData)
	GetTradeData(ctx echo.Context, params GetTradeDataParams) error
	// (GET /v1/userData)
	GetUserData(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// GetDocs converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocs(ctx)
	return err
}

// GetGraphqlPlayground converts echo context to params.
func (w *ServerInterfaceWrapper) GetGraphqlPlayground(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGraphqlPlayground(ctx)
	return err
}

// PostGraphqlQuery converts echo context to params.
func (w *ServerInterfaceWrapper) PostGraphqlQuery(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGraphqlQuery(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetPoolData converts echo context to params.
func (w *ServerInterfaceWrapper) GetPoolData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoolDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPoolData(ctx, params)
	return err
}

// GetStakerData converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerDataParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerData(ctx, params)
	return err
}

// GetStakerTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerTxParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerTx(ctx, params)
	return err
}

// GetSwagger converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwagger(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwagger(ctx)
	return err
}

// GetSwapData converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapData(ctx, params)
	return err
}

// GetSwapTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapTxParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Required query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument sender is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Required query parameter "dest" -------------
	if paramValue := ctx.QueryParam("dest"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument dest is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "dest", ctx.QueryParams(), &params.Dest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dest: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapTx(ctx, params)
	return err
}

// GetTokenData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTokenData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokenDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTokenData(ctx, params)
	return err
}

// GetTradeData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTradeData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTradeDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTradeData(ctx, params)
	return err
}

// GetUserData converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserData(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserData(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v1/assets", wrapper.GetAssets)
	router.GET("/v1/doc", wrapper.GetDocs)
	router.GET("/v1/graphql", wrapper.GetGraphqlPlayground)
	router.POST("/v1/graphql/query", wrapper.PostGraphqlQuery)
	router.GET("/v1/health", wrapper.GetHealth)
	router.GET("/v1/poolData", wrapper.GetPoolData)
	router.GET("/v1/stakerData", wrapper.GetStakerData)
	router.GET("/v1/stakerTx", wrapper.GetStakerTx)
	router.GET("/v1/swagger.json", wrapper.GetSwagger)
	router.GET("/v1/swapData", wrapper.GetSwapData)
	router.GET("/v1/swapTx", wrapper.GetSwapTx)
	router.GET("/v1/tokenData", wrapper.GetTokenData)
	router.GET("/v1/tradeData", wrapper.GetTradeData)
	router.GET("/v1/userData", wrapper.GetUserData)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"2lFIGgAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
