// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// PoolData defines model for PoolData.
type PoolData struct {
	Asset         string  `json:"asset"`
	Depth         float32 `json:"depth"`
	NumStakeTx    float32 `json:"numStakeTx"`
	NumStakers    float32 `json:"numStakers"`
	NumSwaps      float32 `json:"numSwaps"`
	PoolUnits     float32 `json:"poolUnits"`
	Roi12         float32 `json:"roi12"`
	Roi30         float32 `json:"roi30"`
	RoiAT         float32 `json:"roiAT"`
	TotalFeesRune float32 `json:"totalFeesRune"`
	TotalFeesTKN  float32 `json:"totalFeesTKN"`
	Vol24hr       float32 `json:"vol24hr"`
	VolAT         float32 `json:"volAT"`
}

// StakerInfo defines model for StakerInfo.
type StakerInfo struct {
	Address         string  `json:"address"`
	Asset           string  `json:"asset"`
	DateFirstStaked string  `json:"dateFirstStaked"`
	RuneEarned      float32 `json:"runeEarned"`
	RuneStaked      float32 `json:"runeStaked"`
	TokensEarned    float32 `json:"tokensEarned"`
	TokensStaked    float32 `json:"tokensStaked"`
	Units           float32 `json:"units"`
}

// StakerInfoWithAsset defines model for StakerInfoWithAsset.
type StakerInfoWithAsset []string

// SwapData defines model for SwapData.
type SwapData struct {
	Asset       string  `json:"asset"`
	AveFeeRune  float32 `json:"aveFeeRune"`
	AveFeeTkn   float32 `json:"aveFeeTkn"`
	AveSlipRune float32 `json:"aveSlipRune"`
	AveSlipTkn  float32 `json:"aveSlipTkn"`
	AveTxRune   float32 `json:"aveTxRune"`
	AveTxTkn    float32 `json:"aveTxTkn"`
	NumTxRune   float32 `json:"numTxRune"`
	NumTxTkn    float32 `json:"numTxTkn"`
}

// TokenData defines model for TokenData.
type TokenData struct {
	Price  float32 `json:"price"`
	Symbol string  `json:"symbol"`
	Ticker string  `json:"ticker"`
}

// TokenList defines model for TokenList.
type TokenList []string

// GetPoolDataParams defines parameters for GetPoolData.
type GetPoolDataParams struct {
	Asset string `json:"asset"`
}

// GetStakerDataParams defines parameters for GetStakerData.
type GetStakerDataParams struct {
	Staker string  `json:"staker"`
	Asset  *string `json:"asset,omitempty"`
}

// GetStakerTxParams defines parameters for GetStakerTx.
type GetStakerTxParams struct {
	Staker string  `json:"staker"`
	Limit  *int    `json:"limit,omitempty"`
	Offset *int    `json:"offset,omitempty"`
	Asset  *string `json:"asset,omitempty"`
}

// GetSwapDataParams defines parameters for GetSwapData.
type GetSwapDataParams struct {
	Asset string `json:"asset"`
}

// GetSwapTxParams defines parameters for GetSwapTx.
type GetSwapTxParams struct {
	Asset  string `json:"asset"`
	Sender string `json:"sender"`
	Dest   string `json:"dest"`
	Limit  *int   `json:"limit,omitempty"`
	Offset *int   `json:"offset,omitempty"`
}

// GetTokenDataParams defines parameters for GetTokenData.
type GetTokenDataParams struct {
	Symbol string `json:"symbol"`
}

// GetTokensParams defines parameters for GetTokens.
type GetTokensParams struct {
	Token *string `json:"token,omitempty"`
}

// GetTradeDataParams defines parameters for GetTradeData.
type GetTradeDataParams struct {
	Symbol string `json:"symbol"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// This swagger/openapi 3.0 generated documentation// (GET /v1/doc)
	GetDocs(ctx echo.Context) error
	// (GET /v1/graphql)
	GetGraphqlPlayground(ctx echo.Context) error
	// (POST /v1/graphql/query)
	PostGraphqlQuery(ctx echo.Context) error
	// (GET /v1/health)
	GetHealth(ctx echo.Context) error
	// (GET /v1/poolData)
	GetPoolData(ctx echo.Context, params GetPoolDataParams) error
	// (GET /v1/stakerData)
	GetStakerData(ctx echo.Context, params GetStakerDataParams) error
	// (GET /v1/stakerTx)
	GetStakerTx(ctx echo.Context, params GetStakerTxParams) error
	// JSON swagger/openapi 3.0 specification endpoint// (GET /v1/swagger.json)
	GetSwagger(ctx echo.Context) error
	// (GET /v1/swapData)
	GetSwapData(ctx echo.Context, params GetSwapDataParams) error
	// (GET /v1/swapTx)
	GetSwapTx(ctx echo.Context, params GetSwapTxParams) error
	// (GET /v1/tokenData)
	GetTokenData(ctx echo.Context, params GetTokenDataParams) error
	// (GET /v1/tokens)
	GetTokens(ctx echo.Context, params GetTokensParams) error
	// (GET /v1/tradeData)
	GetTradeData(ctx echo.Context, params GetTradeDataParams) error
	// (GET /v1/userData)
	GetUserData(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetDocs converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocs(ctx)
	return err
}

// GetGraphqlPlayground converts echo context to params.
func (w *ServerInterfaceWrapper) GetGraphqlPlayground(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGraphqlPlayground(ctx)
	return err
}

// PostGraphqlQuery converts echo context to params.
func (w *ServerInterfaceWrapper) PostGraphqlQuery(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostGraphqlQuery(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetPoolData converts echo context to params.
func (w *ServerInterfaceWrapper) GetPoolData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPoolDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPoolData(ctx, params)
	return err
}

// GetStakerData converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerDataParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerData(ctx, params)
	return err
}

// GetStakerTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetStakerTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStakerTxParams
	// ------------- Required query parameter "staker" -------------
	if paramValue := ctx.QueryParam("staker"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument staker is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "staker", ctx.QueryParams(), &params.Staker)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter staker: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStakerTx(ctx, params)
	return err
}

// GetSwagger converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwagger(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwagger(ctx)
	return err
}

// GetSwapData converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapDataParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapData(ctx, params)
	return err
}

// GetSwapTx converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwapTx(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSwapTxParams
	// ------------- Required query parameter "asset" -------------
	if paramValue := ctx.QueryParam("asset"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument asset is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "asset", ctx.QueryParams(), &params.Asset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset: %s", err))
	}

	// ------------- Required query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument sender is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Required query parameter "dest" -------------
	if paramValue := ctx.QueryParam("dest"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument dest is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "dest", ctx.QueryParams(), &params.Dest)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dest: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSwapTx(ctx, params)
	return err
}

// GetTokenData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTokenData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokenDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTokenData(ctx, params)
	return err
}

// GetTokens converts echo context to params.
func (w *ServerInterfaceWrapper) GetTokens(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTokensParams
	// ------------- Optional query parameter "token" -------------
	if paramValue := ctx.QueryParam("token"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTokens(ctx, params)
	return err
}

// GetTradeData converts echo context to params.
func (w *ServerInterfaceWrapper) GetTradeData(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTradeDataParams
	// ------------- Required query parameter "symbol" -------------
	if paramValue := ctx.QueryParam("symbol"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument symbol is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "symbol", ctx.QueryParams(), &params.Symbol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter symbol: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTradeData(ctx, params)
	return err
}

// GetUserData converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserData(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserData(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v1/doc", wrapper.GetDocs)
	router.GET("/v1/graphql", wrapper.GetGraphqlPlayground)
	router.POST("/v1/graphql/query", wrapper.PostGraphqlQuery)
	router.GET("/v1/health", wrapper.GetHealth)
	router.GET("/v1/poolData", wrapper.GetPoolData)
	router.GET("/v1/stakerData", wrapper.GetStakerData)
	router.GET("/v1/stakerTx", wrapper.GetStakerTx)
	router.GET("/v1/swagger.json", wrapper.GetSwagger)
	router.GET("/v1/swapData", wrapper.GetSwapData)
	router.GET("/v1/swapTx", wrapper.GetSwapTx)
	router.GET("/v1/tokenData", wrapper.GetTokenData)
	router.GET("/v1/tokens", wrapper.GetTokens)
	router.GET("/v1/tradeData", wrapper.GetTradeData)
	router.GET("/v1/userData", wrapper.GetUserData)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8xYX3PbNgz/Kjxtd3txZSfZbj0/rVvarluvTWv39tDzAyPBFhuJZEjKiS/n774DKVl/",
	"QsrK0qZ70xkAfwB+IAD6LkpEIQUHbnQ0v4t0kkFB7eeFEPk5NRS/pRISlGFgJVRrMPhhdhKieaSNYnwT",
	"7SdRCtJkLQkvi0tQKOFlsTD0Cpa3g2Klg+IbKv1CKUT+iTPjlyrBTk5DkrNZSPJi6ZUYYWj+CkB/LDkM",
	"ayz/fudV2Ir89OdMhWReYPQJrkumII3mnysCelh95xqk+tyan3bK6mDrdNQJ61DSoa/FxmpSOyouv0Bi",
	"MARn84avhadw0lSB1t7SGSgqauAVU9rYo1Ovjio5vKSKd8QtQksO96zbnF0B1wP2TmHghDJQf33iqgRM",
	"DhT2g+uE0nG852bPqdqFYUr+YSZ7USeaGSj8XFQ/UKXozh5wQ+VDWwHdwiuA4DVx4uUVD0kXOZND1igf",
	"MF/eDhkvb0OmvCwGTK3Ubxq4ogewtledALrRtjDazrQT1smtj+8lFoafL6lY4g9N74pLkfvLgSVXoDyi",
	"XszVEQeDSQUX9PEt0w+qRARkVWdJBDc0seZQUJZH8yiFrf7NZEIlGWU8FqqaSTpRTBomeDSP/kDRswWo",
	"LUuAXJSXOUvIi4s31muTw7DKFpR255zEs3j2TFB9hhhCAqeSRfPoDH/HyKnJbEjT7ck0FQl+btxVQT4o",
	"uvMmjebRazDnIrGNGLQUXDuiTmd2NHWd1zd0swE1reDIWTwjWkJCNsDxTEhJimdhnnRZFFTtonm0zJgm",
	"PtOOVVkAN9YtTAXdaGT0vPP7Cs/FeDaKyuw6H4rptVO5yOluo0TJ01EBWqsPb4lszPb7Hur0ugSM6y6S",
	"QnvAL4Su0T9YzUcDZ0Bzt9aEov3TaYxCAkOcOnHKCRCxtvXVIMrW7hXCPOxnWGyKFmDs9vTZB7iQkLD1",
	"jtiuRNCSVKYMVa6rPHFa2NtW9a7mbhtVwqRaDn19YOWPHO8ocOs+lTJniQ1g+kUL3iyb+PWjgnU0j36Y",
	"NtvotFpFp4c4bXa6sdlZRjBbBPuCKlyhNonUdvQdS+Wi0TqSTHceaea4L39O6UEJnPSBOoyN5mlNc/1N",
	"iRIc3q9tXoYoa+2AGNk41WY32a88VNsydtlHqm39krUSRe/quOS7Z8Yw33aXHWR78VRs56xgBvtBmRtN",
	"FJgSdzySwpqWuSGnvwSwrd2oCmDcwMbtKX1wsV7jLYrj+ABoBJkFIJ32YzGftryDlWQU5ZomKAgXlJuc",
	"cX0ZgkXl9EYNgawsKCeUp6SgScY4EAU0pZc53BvU2maqupEEeCoF46Y34v9avH9HQtuBx7qZ8Iu2QjPh",
	"dWvjHwhYjumZ/43r7zlyDpF5+hDKSIq1Epg4N1Qe6T5O40jWvm627l1ADTw93tqs0uOAUtDmCAyqfIv+",
	"GZPzJ2mg721LbNC+dvcc39WwNsf0NNN+IYbqtHlGjrzgh/eft5Zq4aOv+P24rafDweqjkeqxYdrzAlHW",
	"sv/dSta8t49tZA3twT3M5cuba0VTOFpYB6Vj2/Z3Kyj0MFhQpT7+pPikDw+KcZBo4EHEMQ9qW+enVDmu",
	"D8bI+XR6cvprPItn8cn8+ez5zBLbyLVHYXWY+30Pqn85fgeJ84t0/gL5SZOPLxfL6i+QKvvBP0n2q/2/",
	"AQAA//+iwmajVRgAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
